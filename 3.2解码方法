//自己写的，感觉很垃圾。
//总体思路，先说一般情况：只要满足题目一定的条件，那么dp[i]=dp[i-1]+dp[i-2]，其中dp[i]数组存放当前位置所能解码的最大种数。
比如：
  122的种数是2种：{1 22},{1 2 2} 
  而1221的种数是3种：
  由于最后的1和前面的2可以组合21满足题设，所以1221的种数 = 1和前面2组合的情况 + 1和2分开的种数 即：12的种数 + 122的种数
而题目具体分成三个大条件：
  1. s[i]为0，那么需要判断s[i-1]是否是1或2，如果不是则GG，是的话 dp[i]=dp[i-2]
  2. s[i]不为0，同样需要判断s[i-1]是否为1或2，如果不是则进行第三种情况，是的话又要判断
  3. 上面两种都不满足，那么dp[i] = dp[i-1]   eg：1231 i是最后一位的情况，1231的解码数等价于123的解码数，因为31没法组和
注：其中前两种情况又要考虑第2个位置的情况，因为如果直接带入一般情况的话，dp[1-2]会有下标越界的问题，但是dp[1]相对特殊，此位置的值也不一定就是1，要看具体情况，所以考虑了1后程序变得又臭又长。
public int numDecodings(String s) {
    int[] dp = new int[s.length()];
    if(s.charAt(0) == '0') return 0;
    dp[0] = 1;//第一位不是0的话，那么一个数字必然只能解码出一种
    for(int i = 1; i < s.length(); i++){
        if(s.charAt(i) == '0'){
            if(s.charAt(i-1) == '1' || s.charAt(i-1) == '2'){
                if(i == 1){
                    dp[i] = dp[i - 1];
                }else{
                    dp[i] = dp[i - 2];
                } 
            }else{
                return 0;
            }
        }else if(s.charAt(i - 1) == '1' || (s.charAt(i - 1) == '2' && s.charAt(i) >= '1' && s.charAt(i) <= '6')){
            if(i == 1){
                dp[i] = 2;
            }else{
                dp[i] = dp[i - 1] + dp[i - 2];
            }       
        }else{
            dp[i] = dp[i - 1];
        }
    }
    return dp[s.length() - 1];
}
